<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>【源码学习】JDK8 ConcurrentHashMap | 碎碎念回收站</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.74.3" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.4fc0b62e4b82c997bb0041217cd6b979.css" rel="stylesheet">
    

    

    
      

    

    
    
    <meta property="og:title" content="【源码学习】JDK8 ConcurrentHashMap" />
<meta property="og:description" content="认识 与 JDK7 相比舍弃了复杂的分段锁机制，所有的并发安全均由synchronized 与 CAS 机制保证，在存储结构上延续了 JDK8 HashMap 的「链表 &#43; 红黑树」的结构。
关键属性 // 最大容量 private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认容量，与hashmap相同 private static final int DEFAULT_CAPACITY = 16; // 默认并发等级 private static final int DEFAULT_CONCURRENCY_LEVEL = 16; // 扩容因子，不再赘述 private static final float LOAD_FACTOR = 0.75f; // 链表转化为红黑树的阈值 static final int TREEIFY_THRESHOLD = 8; // 红黑树最小容量 static final int MIN_TREEIFY_CAPACITY = 64; // 重要属性，扩容校验码位数，详见后文 private static int RESIZE_STAMP_BITS = 16; // 参与扩容的最大线程数 private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1; // 扩容校验码移位数，详见后文 private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS; // 重要属性，表示此节点正在扩容中，hash值为-1 static final int MOVED = -1; // hash for forwarding nodes  // node数组 transient volatile Node&lt;K,V&gt;[] table; // 扩容后的数组 private transient volatile Node&lt;K,V&gt;[] nextTable; // 十分重要的属性，详解后文 private transient volatile int sizeCtl; // 重要属性，并发扩容索引，详见后文 private transient volatile int transferIndex; sizeCtl 是保证并发安全最重要一个属性，被标记为 volitale，以CAS 方式来对其设值。不同状态下此属性不同的值有不同的意义，在此处先一并列出，便于后文参考：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/cocurrenthashmap_2/" />
<meta property="article:published_time" content="2018-06-18T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-06-18T00:00:00+00:00" />
<meta itemprop="name" content="【源码学习】JDK8 ConcurrentHashMap">
<meta itemprop="description" content="认识 与 JDK7 相比舍弃了复杂的分段锁机制，所有的并发安全均由synchronized 与 CAS 机制保证，在存储结构上延续了 JDK8 HashMap 的「链表 &#43; 红黑树」的结构。
关键属性 // 最大容量 private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认容量，与hashmap相同 private static final int DEFAULT_CAPACITY = 16; // 默认并发等级 private static final int DEFAULT_CONCURRENCY_LEVEL = 16; // 扩容因子，不再赘述 private static final float LOAD_FACTOR = 0.75f; // 链表转化为红黑树的阈值 static final int TREEIFY_THRESHOLD = 8; // 红黑树最小容量 static final int MIN_TREEIFY_CAPACITY = 64; // 重要属性，扩容校验码位数，详见后文 private static int RESIZE_STAMP_BITS = 16; // 参与扩容的最大线程数 private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1; // 扩容校验码移位数，详见后文 private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS; // 重要属性，表示此节点正在扩容中，hash值为-1 static final int MOVED = -1; // hash for forwarding nodes  // node数组 transient volatile Node&lt;K,V&gt;[] table; // 扩容后的数组 private transient volatile Node&lt;K,V&gt;[] nextTable; // 十分重要的属性，详解后文 private transient volatile int sizeCtl; // 重要属性，并发扩容索引，详见后文 private transient volatile int transferIndex; sizeCtl 是保证并发安全最重要一个属性，被标记为 volitale，以CAS 方式来对其设值。不同状态下此属性不同的值有不同的意义，在此处先一并列出，便于后文参考：">
<meta itemprop="datePublished" content="2018-06-18T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-06-18T00:00:00+00:00" />
<meta itemprop="wordCount" content="2411">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="【源码学习】JDK8 ConcurrentHashMap"/>
<meta name="twitter:description" content="认识 与 JDK7 相比舍弃了复杂的分段锁机制，所有的并发安全均由synchronized 与 CAS 机制保证，在存储结构上延续了 JDK8 HashMap 的「链表 &#43; 红黑树」的结构。
关键属性 // 最大容量 private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认容量，与hashmap相同 private static final int DEFAULT_CAPACITY = 16; // 默认并发等级 private static final int DEFAULT_CONCURRENCY_LEVEL = 16; // 扩容因子，不再赘述 private static final float LOAD_FACTOR = 0.75f; // 链表转化为红黑树的阈值 static final int TREEIFY_THRESHOLD = 8; // 红黑树最小容量 static final int MIN_TREEIFY_CAPACITY = 64; // 重要属性，扩容校验码位数，详见后文 private static int RESIZE_STAMP_BITS = 16; // 参与扩容的最大线程数 private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1; // 扩容校验码移位数，详见后文 private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS; // 重要属性，表示此节点正在扩容中，hash值为-1 static final int MOVED = -1; // hash for forwarding nodes  // node数组 transient volatile Node&lt;K,V&gt;[] table; // 扩容后的数组 private transient volatile Node&lt;K,V&gt;[] nextTable; // 十分重要的属性，详解后文 private transient volatile int sizeCtl; // 重要属性，并发扩容索引，详见后文 private transient volatile int transferIndex; sizeCtl 是保证并发安全最重要一个属性，被标记为 volitale，以CAS 方式来对其设值。不同状态下此属性不同的值有不同的意义，在此处先一并列出，便于后文参考："/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        碎碎念回收站
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=http://example.org/posts/cocurrenthashmap_2/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=http://example.org/posts/cocurrenthashmap_2/&amp;text=%e3%80%90%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e3%80%91JDK8%20ConcurrentHashMap" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http://example.org/posts/cocurrenthashmap_2/&amp;title=%e3%80%90%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e3%80%91JDK8%20ConcurrentHashMap" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>


      <h1 class="f1 athelas mt3 mb1">【源码学习】JDK8 ConcurrentHashMap</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-06-18T00:00:00Z">June 18, 2018</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="认识">认识</h2>
<p>与 JDK7 相比舍弃了复杂的分段锁机制，所有的并发安全均由synchronized 与 CAS 机制保证，在存储结构上延续了 JDK8 HashMap 的「链表 + 红黑树」的结构。</p>
<h2 id="关键属性">关键属性</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 最大容量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MAXIMUM_CAPACITY <span style="color:#f92672">=</span> 1 <span style="color:#f92672">&lt;&lt;</span> 30<span style="color:#f92672">;</span>

<span style="color:#75715e">// 默认容量，与hashmap相同
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> DEFAULT_CAPACITY <span style="color:#f92672">=</span> 16<span style="color:#f92672">;</span>

<span style="color:#75715e">// 默认并发等级
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> DEFAULT_CONCURRENCY_LEVEL <span style="color:#f92672">=</span> 16<span style="color:#f92672">;</span>

<span style="color:#75715e">// 扩容因子，不再赘述
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">float</span> LOAD_FACTOR <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">75f</span><span style="color:#f92672">;</span>

<span style="color:#75715e">// 链表转化为红黑树的阈值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> TREEIFY_THRESHOLD <span style="color:#f92672">=</span> 8<span style="color:#f92672">;</span>

<span style="color:#75715e">// 红黑树最小容量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MIN_TREEIFY_CAPACITY <span style="color:#f92672">=</span> 64<span style="color:#f92672">;</span>

<span style="color:#75715e">// 重要属性，扩容校验码位数，详见后文
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> RESIZE_STAMP_BITS <span style="color:#f92672">=</span> 16<span style="color:#f92672">;</span>

<span style="color:#75715e">// 参与扩容的最大线程数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MAX_RESIZERS <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">(</span>32 <span style="color:#f92672">-</span> RESIZE_STAMP_BITS<span style="color:#f92672">))</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>

<span style="color:#75715e">// 扩容校验码移位数，详见后文
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> RESIZE_STAMP_SHIFT <span style="color:#f92672">=</span> 32 <span style="color:#f92672">-</span> RESIZE_STAMP_BITS<span style="color:#f92672">;</span>

<span style="color:#75715e">// 重要属性，表示此节点正在扩容中，hash值为-1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MOVED     <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span> <span style="color:#75715e">// hash for forwarding nodes
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// node数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">volatile</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> table<span style="color:#f92672">;</span>

<span style="color:#75715e">// 扩容后的数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">volatile</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> nextTable<span style="color:#f92672">;</span>

<span style="color:#75715e">// 十分重要的属性，详解后文
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> sizeCtl<span style="color:#f92672">;</span>

<span style="color:#75715e">// 重要属性，并发扩容索引，详见后文
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> transferIndex<span style="color:#f92672">;</span>
</code></pre></div><p>sizeCtl 是保证并发安全最重要一个属性，被标记为 volitale，以CAS 方式来对其设值。不同状态下此属性不同的值有不同的意义，在此处先一并列出，便于后文参考：</p>
<ul>
<li>初始状态：
sizeCtl = 0；表示 table 还未被初始化</li>
<li>正常状态：
sizeCtl &gt; 0：即 0.75n，也就下一次扩容的阈值，其中 0.75 为扩容因子</li>
<li>初始化状态：
sizeCtl = -1：表示 table 正在被初始化</li>
<li>扩容状态：
<strong>sizeCtl = (resizeStamp(n) &laquo; RESIZE_STAMP_SHIFT) + 2 :第一个发起扩容的线程会将 sizeCtl 置为此值，也就是说此时只有一个线程在执行扩容，需要注意的是，此时 sizeCtl 是一个负值</strong></li>
</ul>
<h2 id="关键方法">关键方法</h2>
<h3 id="校验码方法">校验码方法</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">resizeStamp</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">numberOfLeadingZeros</span><span style="color:#f92672">(</span>n<span style="color:#f92672">)</span> <span style="color:#f92672">|</span> <span style="color:#f92672">(</span>1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">(</span>RESIZE_STAMP_BITS <span style="color:#f92672">-</span> 1<span style="color:#f92672">));</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这是扩容时提供的一个生成校验码的方法，我们暂时不用考虑此方法的使用场合，只需知道这个方法做了什么即可。</p>
<p>这个方法的参数是n，表示此时是基于长度为n的table进行扩容而生成校验码，也就是说生成的校验码首先与本次要扩容的数组长度是有关的</p>
<ul>
<li>n = 16时：
Integer.numberOfLeadingZeros(n) = 0001 1100
resizeStamp(16) = 0001 1100 | 1000 0000 0000 0000 = 1000 0000 0001 1100</li>
</ul>
<p>结合此方法理解sizeCtl的这个值：sizeCtl = (resizeStamp(n) &laquo; RESIZE_STAMP_SHIFT) + 2</p>
<ul>
<li>n = 16时：
sizeCtl = 1000 0000 0001 1100 &laquo; 16 + 0010 = 1000 0000 0001 1100 0000 0000 0000 0010</li>
</ul>
<p>也就是说sizeCtl在扩容的某个状态下其高16位为本次扩容的检验码，而低16位表示正在参与扩容的线程数，<strong>+1表示初始化，+2才表示此只有一个线程参与扩容</strong>，+3就表示有两个线程在执行扩容，<strong>同样地每个线程退出扩容时也会将此值-1</strong>，所以后文中出现此判断条件时：(sc - 2) != resizeStamp(n) &laquo; RESIZE_STAMP_SHIFT，也表示判断当前线程是否为最后一个扩容线程，只要这个线程扩容结束，那么整个并发扩容即结束</p>
<h3 id="cas-方法">CAS 方法</h3>
<p>由于jdk8中的cocurrenthashmap大量使用了CAS方法，所以在这里简要介绍一下，以compareAndSwapObject为例，其他的类似：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">native</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">compareAndSwapObject</span><span style="color:#f92672">(</span>Object var1<span style="color:#f92672">,</span> <span style="color:#66d9ef">long</span> var2<span style="color:#f92672">,</span> Object var4<span style="color:#f92672">,</span> Object var5<span style="color:#f92672">);</span>
</code></pre></div><p>此方法有4个参数，对象var1，偏移值var2，预期值var4，要修改的值var5，如果var1偏移var2内存地址上的值和var4相等，那么就把此内存地址上的值修改为var5并且返回true，否则返回false</p>
<h3 id="构造方法">构造方法</h3>
<p>这里只给出参数最多的一个构造方法，其他构造方法只是这个的部分逻辑</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ConcurrentHashMap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> initialCapacity<span style="color:#f92672">,</span>
                            <span style="color:#66d9ef">float</span> loadFactor<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> concurrencyLevel<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!(</span>loadFactor <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0f</span><span style="color:#f92672">)</span> <span style="color:#f92672">||</span> initialCapacity <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> concurrencyLevel <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">();</span>
    <span style="color:#75715e">// 初始容量最小与并发等级相同
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>initialCapacity <span style="color:#f92672">&lt;</span> concurrencyLevel<span style="color:#f92672">)</span>   <span style="color:#75715e">// Use at least as many bins
</span><span style="color:#75715e"></span>        initialCapacity <span style="color:#f92672">=</span> concurrencyLevel<span style="color:#f92672">;</span>   <span style="color:#75715e">// as estimated threads
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> size <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">long</span><span style="color:#f92672">)(</span>1<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">long</span><span style="color:#f92672">)</span>initialCapacity <span style="color:#f92672">/</span> loadFactor<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> cap <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>size <span style="color:#f92672">&gt;=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">long</span><span style="color:#f92672">)</span>MAXIMUM_CAPACITY<span style="color:#f92672">)</span> <span style="color:#f92672">?</span>
        MAXIMUM_CAPACITY <span style="color:#f92672">:</span> tableSizeFor<span style="color:#f92672">((</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span>size<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">sizeCtl</span> <span style="color:#f92672">=</span> cap<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这里需要注意的是计算sizeCtl值的过程：通过初始容量与扩容因子，取到size值，然后通过tableSizeFor(int(size)取到大于等于size整数的最小2的n次方；如果是默认扩容因子0.75那么size就是1.5倍的initialCapacity再加1。这里保证的是当初始化table时若sizeCtl&gt;0，那么table长度一定是2的n次方</p>
<h2 id="put">put()</h2>
<p>如果插入新的元素，则返回值为 null；如果覆盖了旧值，则返回旧值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">putVal</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> onlyIfAbsent<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> value <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">();</span>
    <span style="color:#75715e">// 计算hash码
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> spread<span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">());</span>
    <span style="color:#75715e">// 记录链表长度
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> binCount <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab <span style="color:#f92672">=</span> table<span style="color:#f92672">;;)</span> <span style="color:#f92672">{</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> f<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> fh<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 如果table数组为空说明还未初始化，需要首先调用initTable()进行初始化，详见后文
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tab <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
            tab <span style="color:#f92672">=</span> initTable<span style="color:#f92672">();</span>
        <span style="color:#75715e">// 如果table不为空则根据hash计算索引
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// (1)索引节点为空，则直接新建一个Node放在此位置即可
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// cas成功则put结束
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>f <span style="color:#f92672">=</span> tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> hash<span style="color:#f92672">))</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 注意这里仍旧使用CAS的方式给数组某位置赋值，防止其他线程已经插入后本线程重复插入
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>casTabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)))</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>                   <span style="color:#75715e">// no lock when adding to empty bin
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// (2)如果此节点的hash值为MOVED则说明此位置的链表正在进行扩容
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 本线程调用helpTransfer()进行辅助扩容，详见后文
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>fh <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> MOVED<span style="color:#f92672">)</span>
            tab <span style="color:#f92672">=</span> helpTransfer<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> f<span style="color:#f92672">);</span>
        <span style="color:#75715e">// (3)此索引位置已有节点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            V oldVal <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 防止其他线程操作，这里再次判断i位置是否仍为f节点
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#75715e">// 索引位置节点hash值大于0，说明此处是一个链表
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>fh <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        <span style="color:#75715e">// 记录链表长度
</span><span style="color:#75715e"></span>                        binCount <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
                        <span style="color:#75715e">// 遍历链表
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> f<span style="color:#f92672">;;</span> <span style="color:#f92672">++</span>binCount<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            K ek<span style="color:#f92672">;</span>
                            <span style="color:#75715e">// 有重复key则覆盖旧值，put结束
</span><span style="color:#75715e"></span>                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span>
                                <span style="color:#f92672">((</span>ek <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span>
                                    <span style="color:#f92672">(</span>ek <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>ek<span style="color:#f92672">))))</span> <span style="color:#f92672">{</span>
                                oldVal <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
                                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>onlyIfAbsent<span style="color:#f92672">)</span>
                                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
                                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                            <span style="color:#f92672">}</span>
                            <span style="color:#75715e">// 若无重复key则将新建节点插到链表末端，put结束
</span><span style="color:#75715e"></span>                            Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> pred <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                                pred<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span>
                                                            value<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
                                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                            <span style="color:#f92672">}</span>
                        <span style="color:#f92672">}</span>
                    <span style="color:#f92672">}</span>
                    <span style="color:#75715e">// 如果索引节点是红黑树节点则调用红黑树的put方法
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>f <span style="color:#66d9ef">instanceof</span> TreeBin<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p<span style="color:#f92672">;</span>
                        binCount <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>
                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">((</span>TreeBin<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>f<span style="color:#f92672">).</span><span style="color:#a6e22e">putTreeVal</span><span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span>
                                                        value<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            oldVal <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>onlyIfAbsent<span style="color:#f92672">)</span>
                                p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
                        <span style="color:#f92672">}</span>
                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 如果binCount != 0说明向链表或红黑树中添加一个节点成功
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>binCount <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 若链表长度大于转为红黑树的阈值则进行转换操作，详见后文
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>binCount <span style="color:#f92672">&gt;=</span> TREEIFY_THRESHOLD<span style="color:#f92672">)</span>
                    treeifyBin<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>oldVal <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                    <span style="color:#66d9ef">return</span> oldVal<span style="color:#f92672">;</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 将当前concurrenthashmap元素数量+1并判断是否需要扩容，详见后文
</span><span style="color:#75715e"></span>    addCount<span style="color:#f92672">(</span>1L<span style="color:#f92672">,</span> binCount<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>整个 put() 的过程抛开细节看逻辑还是较为简单的：</p>
<p><img src="https://blog-pankekp-image.oss-cn-beijing.aliyuncs.com/2018-06/2018_06_04_jdk8_put%28%29.png" alt="put"></p>
<h3 id="inittable">initTable()</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> <span style="color:#a6e22e">initTable</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> sc<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 判断table是否未初始化
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 如果sizeCtl为-1则说明其他线程正在执行初始化，线程让出资源
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>sc <span style="color:#f92672">=</span> sizeCtl<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
            Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">yield</span><span style="color:#f92672">();</span> <span style="color:#75715e">// lost initialization race; just spin
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 进行初始化，使用cas方法将sizeCtl置为-1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> SIZECTL<span style="color:#f92672">,</span> sc<span style="color:#f92672">,</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 再次判断，第一个线程初始化好后，循环中的其它线程到此时不用再初始化
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#75715e">// 如果选用的构造方法已经对sizeCtl赋过值，那么就取这个值为数组长度
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 否则sizeCtl为0，使用默认数组长度
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>sc <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> sc <span style="color:#f92672">:</span> DEFAULT_CAPACITY<span style="color:#f92672">;</span>
                    <span style="color:#a6e22e">@SuppressWarnings</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;unchecked&#34;</span><span style="color:#f92672">)</span>
                    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> nt <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[])</span><span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;?,?&gt;[</span>n<span style="color:#f92672">];</span>
                    table <span style="color:#f92672">=</span> tab <span style="color:#f92672">=</span> nt<span style="color:#f92672">;</span>
                    <span style="color:#75715e">// 将此时table长度的0.75倍作为下一次扩容的阈值
</span><span style="color:#75715e"></span>                    sc <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;&gt;&gt;</span> 2<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 将sc赋给sizeCtl，此时sizeCtl处于正常状态，即0.75n
</span><span style="color:#75715e"></span>                sizeCtl <span style="color:#f92672">=</span> sc<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> tab<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>整个initTable()就是保证初始化工作只由一个线程进行，因为put可以并发执行，而initTable()需要确保单线程执行</p>
<h3 id="treeifybin">treeifyBin()</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">treeifyBin</span><span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> b<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> sc<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tab <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 如果链表长度超过转换为红黑树的阈值但是table长度并没有超过64
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 则进行扩容操作，详见后文
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> MIN_TREEIFY_CAPACITY<span style="color:#f92672">)</span>
            tryPresize<span style="color:#f92672">(</span>n <span style="color:#f92672">&lt;&lt;</span> 1<span style="color:#f92672">);</span>
        <span style="color:#75715e">// 否则将index位置的链表转换为红黑树
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>b <span style="color:#f92672">=</span> tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> index<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> b<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 加锁
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> b<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> hd <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> tl <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                    <span style="color:#75715e">// 遍历链表
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> b<span style="color:#f92672">;</span> e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p <span style="color:#f92672">=</span>
                            <span style="color:#66d9ef">new</span> TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">,</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">,</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">,</span>
                                                <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> tl<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                            hd <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                        <span style="color:#66d9ef">else</span>
                            tl<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                        tl <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span>
                    setTabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> index<span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> TreeBin<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>hd<span style="color:#f92672">));</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这个方法转换红黑树的操作并不是我们重点关心的，主要是为了引出这个方法里导致扩容的场景</p>
<p>至此在put过程中与没有直接使用扩容方法的逻辑我们已经基本梳理清楚，以下开始进行扩容相关逻辑的学习</p>
<h2 id="扩容机制">扩容机制</h2>
<h3 id="认识-1">认识</h3>
<p>jdk8中的concurrentahashmap的扩容过程是可以并发进行的，由于抛弃了各种锁转而使用CAS与synchronized维护线程安全，导致整个扩容过程实现起来十分复杂，但是在设计角度讲其实并不难理解，看完整个过程读者应该会和我一样惊叹于Doug Lea对整个扩容机制在并发下的精妙设计</p>
<h3 id="扩容场合">扩容场合</h3>
<h4 id="addcount">addCount()</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// check就是在put的最后一步增加元素个数时传入的链表长度
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addCount</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span> x<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> check<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    CounterCell<span style="color:#f92672">[]</span> as<span style="color:#f92672">;</span> <span style="color:#66d9ef">long</span> b<span style="color:#f92672">,</span> s<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 使用CAS更新baseCount失败的话才进入内部逻辑
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>as <span style="color:#f92672">=</span> counterCells<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span>
        <span style="color:#f92672">!</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapLong</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> BASECOUNT<span style="color:#f92672">,</span> b <span style="color:#f92672">=</span> baseCount<span style="color:#f92672">,</span> s <span style="color:#f92672">=</span> b <span style="color:#f92672">+</span> x<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        CounterCell a<span style="color:#f92672">;</span> <span style="color:#66d9ef">long</span> v<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> m<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">boolean</span> uncontended <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>as <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>m <span style="color:#f92672">=</span> as<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span>
            <span style="color:#f92672">(</span>a <span style="color:#f92672">=</span> as<span style="color:#f92672">[</span>ThreadLocalRandom<span style="color:#f92672">.</span><span style="color:#a6e22e">getProbe</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;</span> m<span style="color:#f92672">])</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span>
            <span style="color:#f92672">!(</span>uncontended <span style="color:#f92672">=</span>
                U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapLong</span><span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> CELLVALUE<span style="color:#f92672">,</span> v <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">,</span> v <span style="color:#f92672">+</span> x<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
            fullAddCount<span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> uncontended<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>check <span style="color:#f92672">&lt;=</span> 1<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 计数
</span><span style="color:#75715e"></span>        s <span style="color:#f92672">=</span> sumCount<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// put过程中如果新增了节点就需要在判断是否需要扩容
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>check <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">,</span> nt<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> sc<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 当计数得到的总节点数大于等于扩容阈值时进行扩容
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>s <span style="color:#f92672">&gt;=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">long</span><span style="color:#f92672">)(</span>sc <span style="color:#f92672">=</span> sizeCtl<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span>
                <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 计算扩容检验码，详见前文
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> rs <span style="color:#f92672">=</span> resizeStamp<span style="color:#f92672">(</span>n<span style="color:#f92672">);</span>
            <span style="color:#75715e">// sc&lt;0说明有线程在执行扩容操作
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>sc <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 判断扩容是否结束，详见后文
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>sc <span style="color:#f92672">&gt;&gt;&gt;</span> RESIZE_STAMP_SHIFT<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> rs <span style="color:#f92672">||</span> sc <span style="color:#f92672">==</span> rs <span style="color:#f92672">+</span> 1 <span style="color:#f92672">||</span>
                    sc <span style="color:#f92672">==</span> rs <span style="color:#f92672">+</span> MAX_RESIZERS <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>nt <span style="color:#f92672">=</span> nextTable<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span>
                    transferIndex <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span>
                    <span style="color:#75715e">// 满足以上任意条件则说明扩容结束，直接跳出
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                <span style="color:#75715e">// 若扩容过程没有结束，则使用CAS方法将sizeCTL+1，表示当前参与扩容的线程数+1
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> SIZECTL<span style="color:#f92672">,</span> sc<span style="color:#f92672">,</span> sc <span style="color:#f92672">+</span> 1<span style="color:#f92672">))</span>
                    <span style="color:#75715e">// 扩容方法，注意这里传入的nt就是全局的nextTable属性
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// nextTable就是扩容后的数组，tranfer过程中需要将tab的数据迁移到nextTable中，这里传入此数组令本线程也参与到数据迁移过程中
</span><span style="color:#75715e"></span>                    transfer<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> nt<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 如果sizeCtl大于等于0，说明当前线程是第一个发起扩容的线程
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// nextTable为null
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 这里将sc替换为(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)正说明了此时本线程第一个进行扩容的线程
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> SIZECTL<span style="color:#f92672">,</span> sc<span style="color:#f92672">,</span>
                                            <span style="color:#f92672">(</span>rs <span style="color:#f92672">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 2<span style="color:#f92672">))</span>
                transfer<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
            s <span style="color:#f92672">=</span> sumCount<span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这个方法在put新增元素完成后执行，如果元素数量+1后满足一定条件则需要进行扩容，是触发扩容的第一种情况</p>
<p>此方法前半部分就是更新整个map的总的元素数量，后半部分才是用来判断是否需要扩容，方法中用来判断扩容是否结束的五个条件会在后文详细讨论</p>
<h4 id="trypresize">tryPresize()</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tryPresize</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> size<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 这里c的取值与构造方法中相同
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>size <span style="color:#f92672">&gt;=</span> <span style="color:#f92672">(</span>MAXIMUM_CAPACITY <span style="color:#f92672">&gt;&gt;&gt;</span> 1<span style="color:#f92672">))</span> <span style="color:#f92672">?</span> MAXIMUM_CAPACITY <span style="color:#f92672">:</span>
        tableSizeFor<span style="color:#f92672">(</span>size <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>size <span style="color:#f92672">&gt;&gt;&gt;</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> sc<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 通过sizeCtl判断是否有其他线程在进行扩容
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>sc <span style="color:#f92672">=</span> sizeCtl<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab <span style="color:#f92672">=</span> table<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 扩容之前需要保证table已经被初始化过
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 这个if的逻辑与initTable()中的相同，这里不再赘述
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tab <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            n <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>sc <span style="color:#f92672">&gt;</span> c<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> sc <span style="color:#f92672">:</span> c<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> SIZECTL<span style="color:#f92672">,</span> sc<span style="color:#f92672">,</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>table <span style="color:#f92672">==</span> tab<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        <span style="color:#a6e22e">@SuppressWarnings</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;unchecked&#34;</span><span style="color:#f92672">)</span>
                        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> nt <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[])</span><span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;?,?&gt;[</span>n<span style="color:#f92672">];</span>
                        table <span style="color:#f92672">=</span> nt<span style="color:#f92672">;</span>
                        sc <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;&gt;&gt;</span> 2<span style="color:#f92672">);</span>
                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
                    sizeCtl <span style="color:#f92672">=</span> sc<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 未达到扩容阈值或以达最大容量则直接跳出
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">&lt;=</span> sc <span style="color:#f92672">||</span> n <span style="color:#f92672">&gt;=</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 进行扩容操作，与addCount()相同，不再赘述
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tab <span style="color:#f92672">==</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> rs <span style="color:#f92672">=</span> resizeStamp<span style="color:#f92672">(</span>n<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>sc <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> nt<span style="color:#f92672">;</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>sc <span style="color:#f92672">&gt;&gt;&gt;</span> RESIZE_STAMP_SHIFT<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> rs <span style="color:#f92672">||</span> sc <span style="color:#f92672">==</span> rs <span style="color:#f92672">+</span> 1 <span style="color:#f92672">||</span>
                    sc <span style="color:#f92672">==</span> rs <span style="color:#f92672">+</span> MAX_RESIZERS <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>nt <span style="color:#f92672">=</span> nextTable<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span>
                    transferIndex <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span>
                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> SIZECTL<span style="color:#f92672">,</span> sc<span style="color:#f92672">,</span> sc <span style="color:#f92672">+</span> 1<span style="color:#f92672">))</span>
                    transfer<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> nt<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> SIZECTL<span style="color:#f92672">,</span> sc<span style="color:#f92672">,</span>
                                            <span style="color:#f92672">(</span>rs <span style="color:#f92672">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 2<span style="color:#f92672">))</span>
                transfer<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这个方法是在当索引处的链表长度超过转换为红黑树的阈值但table的长度小于MIN_TREEIFY_CAPACITY时执行，是触发扩容的第二种情况。扩容部分的逻辑与addCount()相同</p>
<h4 id="helptransfer">helpTransfer()</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> <span style="color:#a6e22e">helpTransfer</span><span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">,</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> nextTab<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> sc<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 判断扩容是否结束，详见后文
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tab <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>f <span style="color:#66d9ef">instanceof</span> ForwardingNode<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span>
        <span style="color:#f92672">(</span>nextTab <span style="color:#f92672">=</span> <span style="color:#f92672">((</span>ForwardingNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>f<span style="color:#f92672">).</span><span style="color:#a6e22e">nextTable</span><span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> rs <span style="color:#f92672">=</span> resizeStamp<span style="color:#f92672">(</span>tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>nextTab <span style="color:#f92672">==</span> nextTable <span style="color:#f92672">&amp;&amp;</span> table <span style="color:#f92672">==</span> tab <span style="color:#f92672">&amp;&amp;</span>
                <span style="color:#f92672">(</span>sc <span style="color:#f92672">=</span> sizeCtl<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 仍旧与以上两个方法中的if判断条件类似
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 但是注意这里少了一个条件：(nt = nextTable) == null
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 因为nextTable为null时说明扩容完毕了，这里先给出这个结论，详见后文
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>sc <span style="color:#f92672">&gt;&gt;&gt;</span> RESIZE_STAMP_SHIFT<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> rs <span style="color:#f92672">||</span> sc <span style="color:#f92672">==</span> rs <span style="color:#f92672">+</span> 1 <span style="color:#f92672">||</span>
                sc <span style="color:#f92672">==</span> rs <span style="color:#f92672">+</span> MAX_RESIZERS <span style="color:#f92672">||</span> transferIndex <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> SIZECTL<span style="color:#f92672">,</span> sc<span style="color:#f92672">,</span> sc <span style="color:#f92672">+</span> 1<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                transfer<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> nextTab<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> nextTab<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> table<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>当进行put时索引处的节点的hash值为-1的话，说明有线程正在对table扩容，此时会调用此方法进行辅助扩容，这是会触发扩容的第三种情况，需要注意的是ForwardingNode这个类：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ForwardingNode</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">extends</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">final</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> nextTable<span style="color:#f92672">;</span>
    ForwardingNode<span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>MOVED<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">nextTable</span> <span style="color:#f92672">=</span> tab<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// 详见get()
</span><span style="color:#75715e"></span>    find<span style="color:#f92672">()</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这个类会持有一个nextTable的引用，指向扩容后的table数组。在扩容操作中需要将数据从table中转移至nextTable中，如果table中某个节点的数据已经被转移完毕，则在table的此位置放置一个ForwardingNode节点，其hash值为MOVED，说明扩容过程尚未完成</p>
<h3 id="扩容过程">扩容过程</h3>
<p>到此我们已经梳理了会触发扩容的三种情况，这三种情况种均含有逻辑类似的代码段，在本节我们会看到完整的扩容过程，结合扩容过程会将此之前一些或略过的代码逻辑讨论清楚，理解了扩容过程之后再看之前的触发扩容的三种场景的逻辑会更加清晰</p>
<h4 id="认识-2">认识</h4>
<p>这里再重申一遍，jdk8的concurrenthashmap的扩容过程是能够多线程参与执行的</p>
<p>由于扩容过程的实现比较复杂，这里先简要说明下扩容的大致逻辑：</p>
<ol>
<li>table数组长度为n，需要将这n个位置的数据均迁移到nextTable中，所以共有n个迁移任务。每个线程负责一个迁移任务，每当完成一个迁移任务后再检查是否还有需要迁移的任务没有线程负责，有的话允许其他线程进行辅助迁移即可</li>
<li>为了提升效率，Doug Lea大神在迁移过程中加入了一个stride变量，这个变量指示了每个线程负责的迁移任务数</li>
<li>同时为了协调多个线程的并发迁移，使用了transferIndex变量。在迁移开始时此变量指向table的末端，<strong>从后向前</strong>地每stride个任务属于一个线程，然后移动transferIndex指向新的位置，重复上述过程</li>
</ol>
<h4 id="transfer">transfer()</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">transfer</span><span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">,</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> nextTab<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">,</span> stride<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 选取stride的值，单核CPU为n，多核CPU为 (n&gt;&gt;&gt;3)/NCPU，最小值16
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>stride <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>NCPU <span style="color:#f92672">&gt;</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;&gt;&gt;</span> 3<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> NCPU <span style="color:#f92672">:</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> MIN_TRANSFER_STRIDE<span style="color:#f92672">)</span>
        stride <span style="color:#f92672">=</span> MIN_TRANSFER_STRIDE<span style="color:#f92672">;</span> <span style="color:#75715e">// subdivide range
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 迁移开始之前需要保证nextTable不为null
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 触发扩容的三种情况会保证第一个发起扩容的线程出入的nextTab为null
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这里初始化后会将nextTab赋给全局的nextTable，保证后续参与扩容的线程拿到的nextTable正是正在参与扩容的nextTable
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nextTab <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>            <span style="color:#75715e">// initiating
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
            <span style="color:#a6e22e">@SuppressWarnings</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;unchecked&#34;</span><span style="color:#f92672">)</span>
            <span style="color:#75715e">// 容量翻倍
</span><span style="color:#75715e"></span>            Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> nt <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[])</span><span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;?,?&gt;[</span>n <span style="color:#f92672">&lt;&lt;</span> 1<span style="color:#f92672">];</span>
            nextTab <span style="color:#f92672">=</span> nt<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Throwable ex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>      <span style="color:#75715e">// try to cope with OOME
</span><span style="color:#75715e"></span>            sizeCtl <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 将初始化完成的nextTab赋给全局的nextTable
</span><span style="color:#75715e"></span>        nextTable <span style="color:#f92672">=</span> nextTab<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 将transferIndex指向table的末端
</span><span style="color:#75715e"></span>        transferIndex <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">int</span> nextn <span style="color:#f92672">=</span> nextTab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 生成ForwardingNode节点，作用前文已有讨论，注意这里传入了初始化后的nextTab
</span><span style="color:#75715e"></span>    ForwardingNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> fwd <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ForwardingNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>nextTab<span style="color:#f92672">);</span>
    <span style="color:#75715e">// advance可以理解为一个标记，为true表示一个迁移任务已经完成
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">boolean</span> advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// finishing为true时表示整个数据迁移过程已经完成
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">boolean</span> finishing <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span> <span style="color:#75715e">// to ensure sweep before committing nextTab
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// i为索引，通过--i来遍历table[i]，指向当前处理的某个迁移任务
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// bound为边界索引，指向当前迁移任务段的最后一个任务
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span> bound <span style="color:#f92672">=</span> 0<span style="color:#f92672">;;)</span> <span style="color:#f92672">{</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> f<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> fh<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 这个while循环就是为了进行从table[i]到table[bound]节点的遍历
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>advance<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> nextIndex<span style="color:#f92672">,</span> nextBound<span style="color:#f92672">;</span>
            <span style="color:#75715e">// 线程每次处理完一个节点后都会将advance再次置为true，使其能够再次到达这里执行--i从而进行下一个节点的数据迁移
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 当处理完bound节点后就不会在进入此分支，会再次进入第三个分支被分配任务执行数据迁移工作
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 当线程进入循环时时一般会先进入第三个分支领取迁移任务
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 除非在第二个分支判断扩容结束，i=-1
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 或finishing为true，即整个扩容过程已完成，此时同样i=0-1=-1
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(--</span>i <span style="color:#f92672">&gt;=</span> bound <span style="color:#f92672">||</span> finishing<span style="color:#f92672">)</span>
                advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#75715e">// 这个分支是结束transfer()的条件，每个执行扩容的线程最多进入一次这个分支，因为一旦某个线程执行迁移够快以至于将最后一段也执行了，那么就会进入这个分支，
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 当transferIndex&lt;=0时表示已经没有需要迁移的任务了，将i置为-1，advance值为false，准备退出transfer()
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 这里=0时表示移动到了table的头部，说明本线程执行得够快，已经将最后一段迁移任务执行完了
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 而&lt;0我猜测是由于并发导致多个线程重复操作所造成的，仅供参考
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>nextIndex <span style="color:#f92672">=</span> transferIndex<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                i <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
                advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 设置transferIndex，bound，i
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 由于是从后向前遍历，所以nextIndex表示还有多少个迁移任务需要执行
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 注意这个值在第一次迁移时取的是数组长度，也就是说nextIndex-1才指向的是table的最后一个节点
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span>
                        <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> TRANSFERINDEX<span style="color:#f92672">,</span> nextIndex<span style="color:#f92672">,</span>
                        nextBound <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>nextIndex <span style="color:#f92672">&gt;</span> stride <span style="color:#f92672">?</span>
                                    nextIndex <span style="color:#f92672">-</span> stride <span style="color:#f92672">:</span> 0<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
                bound <span style="color:#f92672">=</span> nextBound<span style="color:#f92672">;</span>
                <span style="color:#75715e">// i指向当前迁移任务段的第一个任务
</span><span style="color:#75715e"></span>                i <span style="color:#f92672">=</span> nextIndex <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
                <span style="color:#75715e">// 本线程迁移任务分配完成，跳出循环
</span><span style="color:#75715e"></span>                advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 当i&lt;0时说明本线程的扩容任务已完成
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 至于i&gt;=n与i+n&gt;=nextn，这里的相关逻辑我没与看出i会满足这两个条件，猜测是仍旧是由于并发下多个线程重复操作造成的，仅供参考
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> i <span style="color:#f92672">&gt;=</span> n <span style="color:#f92672">||</span> i <span style="color:#f92672">+</span> n <span style="color:#f92672">&gt;=</span> nextn<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> sc<span style="color:#f92672">;</span>
            <span style="color:#75715e">// 如果整个扩容过程都完成了那么就将全局的nextTable置null
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>finishing<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                nextTable <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                <span style="color:#75715e">// 将扩容用的临时nextTab的值赋回给全局table
</span><span style="color:#75715e"></span>                table <span style="color:#f92672">=</span> nextTab<span style="color:#f92672">;</span>
                <span style="color:#75715e">// 计算新的扩容阈值
</span><span style="color:#75715e"></span>                sizeCtl <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&lt;&lt;</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">-</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;&gt;&gt;</span> 1<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 如果本线程的扩容任务完执行的够快已经将最后一段迁移任务执行完毕就会进入这个分支
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 此处使用CAS将sizeCtl的值减1，表示有一个线程退出扩容，详见检验方法
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>U<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSwapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> SIZECTL<span style="color:#f92672">,</span> sc <span style="color:#f92672">=</span> sizeCtl<span style="color:#f92672">,</span> sc <span style="color:#f92672">-</span> 1<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 判断是本线程是否为最后一个扩容线程，不是则直接退出
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>sc <span style="color:#f92672">-</span> 2<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> resizeStamp<span style="color:#f92672">(</span>n<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span style="color:#f92672">)</span>
                    <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
                <span style="color:#75715e">// 如果本线程是最后一个扩容线程就将finishing置为true
</span><span style="color:#75715e"></span>                finishing <span style="color:#f92672">=</span> advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                i <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span> <span style="color:#75715e">// recheck before commit
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 如果节点是null，那么使用CAS将ForwardingNode插入到此节点表示此节点的迁移任务已完成
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>f <span style="color:#f92672">=</span> tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">))</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
            advance <span style="color:#f92672">=</span> casTabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> fwd<span style="color:#f92672">);</span>
        <span style="color:#75715e">// 如果hash值为-1说明此节点就是一个ForwardingNode节点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>fh <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> MOVED<span style="color:#f92672">)</span>
            advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span> <span style="color:#75715e">// already processed
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 否则就对此节点加锁，进行数据迁移操作
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 判断i位置节点没有变化
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> ln<span style="color:#f92672">,</span> hn<span style="color:#f92672">;</span>
                    <span style="color:#75715e">// 如果节点hash值大于0说明是链表
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>fh <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        <span style="color:#75715e">// 这里与jdk8的hashmap的rehash原理相同，不再赘述
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">int</span> runBit <span style="color:#f92672">=</span> fh <span style="color:#f92672">&amp;</span> n<span style="color:#f92672">;</span>
                        <span style="color:#75715e">// 注意这个指针
</span><span style="color:#75715e"></span>                        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> lastRun <span style="color:#f92672">=</span> f<span style="color:#f92672">;</span>
                        <span style="color:#75715e">// 遍历链表
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span> p <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> p <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">&amp;</span> n<span style="color:#f92672">;</span>
                            <span style="color:#75715e">// 注意这里，这个分支在整个遍历链表的过程中会令lastRun指向最后一个与头节点runBit值相同的节点的下一个节点
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// 也就是说lastRun及其之后的节点的hash&amp;n的值与头节点均不同，这样可以一次将这些节点挂在hn指针上
</span><span style="color:#75715e"></span>                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>b <span style="color:#f92672">!=</span> runBit<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                                runBit <span style="color:#f92672">=</span> b<span style="color:#f92672">;</span>
                                lastRun <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                            <span style="color:#f92672">}</span>
                        <span style="color:#f92672">}</span>
                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>runBit <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            ln <span style="color:#f92672">=</span> lastRun<span style="color:#f92672">;</span>
                            hn <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                        <span style="color:#f92672">}</span>
                        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                            hn <span style="color:#f92672">=</span> lastRun<span style="color:#f92672">;</span>
                            ln <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                        <span style="color:#f92672">}</span>
                        <span style="color:#75715e">// 以下与jdk8的hashmap的rehash原理相同，不再赘述
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p <span style="color:#f92672">=</span> f<span style="color:#f92672">;</span> p <span style="color:#f92672">!=</span> lastRun<span style="color:#f92672">;</span> p <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            <span style="color:#66d9ef">int</span> ph <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">;</span> K pk <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">;</span> V pv <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>ph <span style="color:#f92672">&amp;</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
                                ln <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>ph<span style="color:#f92672">,</span> pk<span style="color:#f92672">,</span> pv<span style="color:#f92672">,</span> ln<span style="color:#f92672">);</span>
                            <span style="color:#66d9ef">else</span>
                                hn <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>ph<span style="color:#f92672">,</span> pk<span style="color:#f92672">,</span> pv<span style="color:#f92672">,</span> hn<span style="color:#f92672">);</span>
                        <span style="color:#f92672">}</span>
                        setTabAt<span style="color:#f92672">(</span>nextTab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> ln<span style="color:#f92672">);</span>
                        setTabAt<span style="color:#f92672">(</span>nextTab<span style="color:#f92672">,</span> i <span style="color:#f92672">+</span> n<span style="color:#f92672">,</span> hn<span style="color:#f92672">);</span>
                        setTabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> fwd<span style="color:#f92672">);</span>
                        advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span>
                    <span style="color:#75715e">// 红黑树的迁移，不做详解,原理类似
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>f <span style="color:#66d9ef">instanceof</span> TreeBin<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        TreeBin<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>TreeBin<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>f<span style="color:#f92672">;</span>
                        TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> lo <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> loTail <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                        TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> hi <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> hiTail <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                        <span style="color:#66d9ef">int</span> lc <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span> hc <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
                        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">first</span><span style="color:#f92672">;</span> e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">;</span>
                            TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span>
                                <span style="color:#f92672">(</span>h<span style="color:#f92672">,</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">,</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>h <span style="color:#f92672">&amp;</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> loTail<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                                    lo <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                                <span style="color:#66d9ef">else</span>
                                    loTail<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                                loTail <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                                <span style="color:#f92672">++</span>lc<span style="color:#f92672">;</span>
                            <span style="color:#f92672">}</span>
                            <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> hiTail<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                                    hi <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                                <span style="color:#66d9ef">else</span>
                                    hiTail<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                                hiTail <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
                                <span style="color:#f92672">++</span>hc<span style="color:#f92672">;</span>
                            <span style="color:#f92672">}</span>
                        <span style="color:#f92672">}</span>
                        ln <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>lc <span style="color:#f92672">&lt;=</span> UNTREEIFY_THRESHOLD<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> untreeify<span style="color:#f92672">(</span>lo<span style="color:#f92672">)</span> <span style="color:#f92672">:</span>
                            <span style="color:#f92672">(</span>hc <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">new</span> TreeBin<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>lo<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> t<span style="color:#f92672">;</span>
                        hn <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>hc <span style="color:#f92672">&lt;=</span> UNTREEIFY_THRESHOLD<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> untreeify<span style="color:#f92672">(</span>hi<span style="color:#f92672">)</span> <span style="color:#f92672">:</span>
                            <span style="color:#f92672">(</span>lc <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">new</span> TreeBin<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>hi<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> t<span style="color:#f92672">;</span>
                        setTabAt<span style="color:#f92672">(</span>nextTab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> ln<span style="color:#f92672">);</span>
                        setTabAt<span style="color:#f92672">(</span>nextTab<span style="color:#f92672">,</span> i <span style="color:#f92672">+</span> n<span style="color:#f92672">,</span> hn<span style="color:#f92672">);</span>
                        setTabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> fwd<span style="color:#f92672">);</span>
                        advance <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ol>
<li>
<p>transfer()过程可以分为两部分，前半部分就是给线程分配迁移任务，即控制advance属性来进入while循环来进行迁移任务的更新、再领迁移任务、退出等逻辑；后半部分就是线程针对一个节点执行迁移任务，两部分套在一个大的死循环里</p>
</li>
<li>
<p>transfer()只是进行数据迁移，并不是扩容的全部，这个方法需要有外围的三个会触发扩容场景的方法来控制传入此方法的nextTab是否为null</p>
</li>
<li>
<p>关于((nextIndex = transferIndex) &lt;= 0)分支：</p>
<ul>
<li>每个线程至多进入一次此分支</li>
<li>假入本线程执行迁移任务够快，以至于将最后一段扩容任务都执行完毕了，那么就会进入此分支，从而进入(i &lt; 0 || i &gt;= n || i + n &gt;= nextn)分支</li>
<li>此时假设finishing为false，也就是说还有其他线程正在执行迁移任务
<ul>
<li>那么本线程尝试将sizeCtl-1，-1成功则判断自己是否为最后一个扩容线程
<ul>
<li>是最后一个线程的话就将finishing值为true，这样其他线程进入扩容时不会再进入((nextIndex = transferIndex) &lt;= 0)分支，会在上一层判断finishing为true直接退出transfer()</li>
<li>否则直接退出</li>
</ul>
</li>
<li>如果尝试-1失败则会再次进入(i &lt; 0 || i &gt;= n || i + n &gt;= nextn)分支判断
<ul>
<li>finishing为false则重复上述过程</li>
<li>此时finishing不会为true，因为即使第一次判断finishing为false时的那些未完成迁移的线程此时已经完成了，但是由于本线程sizeCtl-1未成功，其他线程判断(sc - 2) != resizeStamp(n) &laquo; RESIZE_STAMP_SHIFT)时一定是成立的，那么这些线程就直接退出，没有机会将finishing置为true</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>关于前文略过的if分支：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">((</span>sc <span style="color:#f92672">&gt;&gt;&gt;</span> RESIZE_STAMP_SHIFT<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> rs <span style="color:#f92672">||</span> sc <span style="color:#f92672">==</span> rs <span style="color:#f92672">+</span> 1 <span style="color:#f92672">||</span> sc <span style="color:#f92672">==</span> rs <span style="color:#f92672">+</span> MAX_RESIZERS <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>nt <span style="color:#f92672">=</span> nextTable<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> transferIndex <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span>
</code></pre></div><p>以上的五个条件均是在触发扩容时用来判断扩容是否结束</p>
<ul>
<li>(sc &raquo;&gt; RESIZE_STAMP_SHIFT) != rs：由于校验码是基于当前table生成的，所以校验码不同说明*table长度已经变化了</li>
<li>sc == rs + 1：在校验码方法中已经讨论过+1情况是初始情况，表示没有线程参与扩容</li>
<li>sc == rs + MAX_RESIZERS：MAX_RESIZERS是能参与扩容的最大线程数</li>
<li>(nt = nextTable) == null：在transfer()我们已经知道nextTable为null表示扩容结束</li>
<li>transferIndex &lt;= 0：同上</li>
</ul>
</li>
</ol>
<h2 id="get">get()</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">;</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">,</span> p<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> eh<span style="color:#f92672">;</span> K ek<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> spread<span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">());</span>
    <span style="color:#75715e">// 判断table及节点非空
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span>
        <span style="color:#f92672">(</span>e <span style="color:#f92672">=</span> tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> h<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 判断hash
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>eh <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> h<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 判断key
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>ek <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>ek <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>ek<span style="color:#f92672">)))</span>
                <span style="color:#66d9ef">return</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 头节点hash值小于0说明是ForwardingNode节点或红黑树节点，调用相应的方法
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>eh <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">find</span><span style="color:#f92672">(</span>h<span style="color:#f92672">,</span> key<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 遍历链表
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> h <span style="color:#f92672">&amp;&amp;</span>
                <span style="color:#f92672">((</span>ek <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>ek <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>ek<span style="color:#f92672">))))</span>
                <span style="color:#66d9ef">return</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>get方法实在是非常简单，只有一点需要注意，当节点是ForwardingNode时，ForwardingNode重写了find方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> h<span style="color:#f92672">,</span> Object k<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// loop to avoid arbitrarily deep recursion on forwarding nodes
</span><span style="color:#75715e"></span>    outer<span style="color:#f92672">:</span> <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab <span style="color:#f92672">=</span> nextTable<span style="color:#f92672">;;)</span> <span style="color:#f92672">{</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>k <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> tab <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span>
            <span style="color:#f92672">(</span>e <span style="color:#f92672">=</span> tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> h<span style="color:#f92672">))</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> eh<span style="color:#f92672">;</span> K ek<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>eh <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> h <span style="color:#f92672">&amp;&amp;</span>
                <span style="color:#f92672">((</span>ek <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> k <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>ek <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> k<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>ek<span style="color:#f92672">))))</span>
                <span style="color:#66d9ef">return</span> e<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>eh <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e <span style="color:#66d9ef">instanceof</span> ForwardingNode<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    tab <span style="color:#f92672">=</span> <span style="color:#f92672">((</span>ForwardingNode<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>e<span style="color:#f92672">).</span><span style="color:#a6e22e">nextTable</span><span style="color:#f92672">;</span>
                    <span style="color:#66d9ef">continue</span> outer<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
                <span style="color:#66d9ef">else</span>
                    <span style="color:#66d9ef">return</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">find</span><span style="color:#f92672">(</span>h<span style="color:#f92672">,</span> k<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>find方法的逻辑并不复杂，我们需要知道的是正是由于在扩容过程中ForwardingNode的nextTable指向了全局的nextTable，所以即使在扩容过程中get方法也可以通过ForwardingNode的find方法找到处于要查找的kv对</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy;  碎碎念回收站 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
